"""Add many-to-many relationship between invitations and users

Revision ID: d0a4dfc55dc4
Revises: eb1f0c1fcdd4
Create Date: 2025-08-14 15:16:55.104289

"""

import sqlalchemy as sa
from alembic import op

# revision identifiers, used by Alembic.
revision = "d0a4dfc55dc4"
down_revision = "eb1f0c1fcdd4"
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table(
        "invitation_user",
        sa.Column("invite_id", sa.Integer(), nullable=False),
        sa.Column("user_id", sa.Integer(), nullable=False),
        sa.Column("used_at", sa.DateTime(), nullable=False),
        sa.Column("server_id", sa.Integer(), nullable=True),
        sa.ForeignKeyConstraint(["invite_id"], ["invitation.id"], ondelete="CASCADE"),
        sa.ForeignKeyConstraint(
            ["server_id"],
            ["media_server.id"],
        ),
        sa.ForeignKeyConstraint(["user_id"], ["user.id"], ondelete="CASCADE"),
        sa.PrimaryKeyConstraint("invite_id", "user_id"),
    )

    # Populate the new table with existing invitation-user relationships
    # This preserves existing data for backward compatibility
    connection = op.get_bind()

    # Step 1: Migrate existing used_by_id relationships
    result1 = connection.execute(
        sa.text("""
        SELECT i.id as invite_id, i.used_by_id as user_id,
               COALESCE(i.used_at, i.created) as used_at,
               u.server_id as server_id
        FROM invitation i
        JOIN user u ON i.used_by_id = u.id
        WHERE i.used_by_id IS NOT NULL
    """)
    )

    for row in result1:
        # Insert into the new junction table
        connection.execute(
            sa.text("""
            INSERT OR IGNORE INTO invitation_user (invite_id, user_id, used_at, server_id)
            VALUES (:invite_id, :user_id, :used_at, :server_id)
        """),
            {
                "invite_id": row.invite_id,
                "user_id": row.user_id,
                "used_at": row.used_at,
                "server_id": row.server_id,
            },
        )

    # Step 2: Recover additional relationships using User.code field
    # This captures users who used invitations but weren't tracked in used_by_id
    # (especially important for unlimited invitations with multiple users)
    result2 = connection.execute(
        sa.text("""
        SELECT DISTINCT i.id as invite_id, u.id as user_id,
               COALESCE(i.used_at, i.created) as used_at,
               u.server_id as server_id
        FROM invitation i
        JOIN user u ON u.code = i.code
        WHERE u.code IS NOT NULL
          AND u.code != ''
          AND NOT EXISTS (
              -- Only add if not already in the junction table from Step 1
              SELECT 1 FROM invitation_user iu
              WHERE iu.invite_id = i.id AND iu.user_id = u.id
          )
    """)
    )

    recovered_count = 0
    for row in result2:
        # Insert additional recovered relationships
        connection.execute(
            sa.text("""
            INSERT OR IGNORE INTO invitation_user (invite_id, user_id, used_at, server_id)
            VALUES (:invite_id, :user_id, :used_at, :server_id)
        """),
            {
                "invite_id": row.invite_id,
                "user_id": row.user_id,
                "used_at": row.used_at,
                "server_id": row.server_id,
            },
        )
        recovered_count += 1

    # Log the recovery results (this will appear in migration output)
    if recovered_count > 0:
        print(
            f"Migration: Recovered {recovered_count} additional invitation-user relationships from User.code field"
        )

    # Step 3: Fix server usage flags for invitations that have users
    # This ensures the frontend will display users correctly by marking servers as used
    # when invitations have associated users
    print("Migration: Fixing server usage flags for consistency...")

    # Find invitations that have users but servers not marked as used
    invitations_with_users = connection.execute(
        sa.text("""
        SELECT DISTINCT iu.invite_id
        FROM invitation_user iu
    """)
    ).fetchall()

    server_fixes = 0
    for row in invitations_with_users:
        invite_id = row.invite_id

        # Mark all servers for this invitation as used if they aren't already
        result = connection.execute(
            sa.text("""
            UPDATE invitation_server
            SET used = 1, used_at = CURRENT_TIMESTAMP
            WHERE invite_id = :invite_id AND used = 0
        """),
            {"invite_id": invite_id},
        )

        if result.rowcount > 0:
            server_fixes += result.rowcount

        # Also ensure the main invitation is marked as used
        connection.execute(
            sa.text("""
            UPDATE invitation
            SET used = 1, used_at = COALESCE(used_at, CURRENT_TIMESTAMP)
            WHERE id = :invite_id AND used = 0
        """),
            {"invite_id": invite_id},
        )

    if server_fixes > 0:
        print(
            f"Migration: Fixed {server_fixes} server usage flags for data consistency"
        )

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table("invitation_user")
    # ### end Alembic commands ###
